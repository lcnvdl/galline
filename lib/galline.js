/*

Generated by JsBuild
http://www.lucianorasente.com.ar

Date: 29/06/2014 
Files:
    def.js
    core.js
    module.js
    timer.js

*/

var Gln = Gln || {};

Gln.Com = {};

Gln.Mod = {};

Gln.Res = {};

Gln.Entities = {
    Shapes: {},
    Test: {}
};

Gln.defaults = {

    DEBUG: true,

    EXAMPLE: true,

    View: {
        size: [400, 300]    //  Array or string ("screen")
    },

    Renderer: {

        WebGL: {
            antialias: true
        },

        WebGLProperties: {
            shadowMapEnabled: false
        },

        Canvas: {

        }
    },

    Physics: {
        UPS: 60     //  Updates per second
    }
};

Gln.Engine = GE.Klass(GE.Engine, {

    $name: "Gln.Engine",

    tClock: null,
    gRenderer: null,
    gContainer: null,
    gScene: null,
    tControls: null,
    tEffects: null,
    gRenderFn: null,
    tAssignedRenderer: null,

    gScreen: {
        w: 0,
        h: 0,
        aspect: 0
    },

    initialize: function(containerId) {
        this.$super();

        if(typeof containerId === 'undefined') {
            containerId = "game-container";
            GE.jQuery("<div>").attr("id", containerId).appendTo("body");
        }

        if(containerId.indexOf("#") != 0) {
            containerId = "#" + containerId;
        }

        this.gContainer = GE.jQuery(containerId);
        this.trigger(GE.Events.Engine.READY);
    },

    start: function(args) {

        //
        //  Preparation
        //

        var def = Gln.defaults;

        this.tClock = new THREE.Clock();
        this.gScene = new PIXI.Stage(0x66FF99);
        
        var size = def.View.size;
        
        if(typeof size === 'string') {
            if(size == "screen") {
                this.gScreen.w = window.innerWidth;
                this.gScreen.h = window.innerHeight; 
            }
            else {
                throw "Invalid size";
            }
        }
        else {
            this.gScreen.x = size[0];
            this.gScreen.y = size[1];
        }
        
        this.gScreen.aspect = this.gScreen.w/this.gScreen.h;

        //
        //  Renderer
        //

        this.gRenderer = PIXI.autoDetectRenderer(400, 300);
        this.gRenderFn = this.__render;

        this.gContainer.append(this.gContainer.view);

        if(def.DEBUG && Stats) {

            var stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.bottom = '0px';
            stats.domElement.style.zIndex = 100;
            this.gContainer.append( stats.domElement );

            this.on("stats", stats, GE.Events.Engine.POSUPDATE, function() {
                this.update();
            });

        }

        //
        //  Start
        //
        
        var $this = this;

        this.$super(args, function() {

            $this.trigger(GE.Events.Engine.START);
            $this.animate();

        });

        return this;
    },

    animate: function() {
        requestAnimationFrame( function() {GE.engine.animate();} );

        this.render();
        this.update(this.tClock.getDelta());
    },

    /**
     * Adds an effect.
     *
     * @param name
     * @param [opts]
     * @param [fn]
     * @returns {*}
     */
    addEffect: function(name, opts, fn) {

        return this;
    },

    clearEffects: function() {

        return this;
    },

    getScreen: function() {
        return {
            width: this.gScreen.w,
            height: this.gScreen.h
        };
    },

    updateScreenSize: function() {
        /*var e = GE.engine,
            assigned = e.tAssignedRenderer,
            renderer = e.tRenderer,
            w = window.innerWidth,
            h = window.innerHeight,
            a = w/h;

        renderer.setSize( w, h );

        if(assigned != renderer && typeof assigned.setSize !== 'undefined') {
            assigned.setSize(w, h);
        }

        GE.jQuery.each(e.getSceneCameras(), function(name, cam) {
            cam.aspect = a;
            cam.updateProjectionMatrix();
        });*/
    },

    render: function() {
        var scene = this.getCurrentScene();

        if(!scene)
            return;

        this.tRenderFn();
    },

    __render: function() {

        var renderer = this.tRenderer,
            world = this.tScene;
            
        renderer.render(world);

    }
});

//
//  Dat.GUI Module.
//

AGE.Mod.GUI = AGE.Mod.GUI || {};

/**
 *  Dat.GUI implementation.
 *
 *  @class DatGUI
 *  @constructor
 */
AGE.Mod.GUI.DatGUI = GE.Klass(GE.Module, {

    //  *****************************
    //  Class Definitions
    //  *****************************

    $name: "Mod.GUI.DatGUI",

    name: "datgui",

    //  *****************************
    //  Attributes
    //  *****************************

    file: "gui/datgui/dat.gui.min.js",

    //  *****************************
    //  Ctor
    //  *****************************

    initialize: function (file) {

        this.async = true;
        this.file = file || this.file;

        //GE.engine.datgui = this;

    },

    //  *****************************
    //  Overrides
    //  *****************************

    load: function (success, fail) {

        if(!document.dat || !document.dat.gui)  {
            var name = this.name;
            if(typeof TWEEN === 'undefined')  {
                GE.loadScript(GE.Path.combine(AGE.Folders.Modules, this.file))
                    .done(function(){success(name);})
                    .fail(function(){fail(name);});
            }
        }

    },

    dispose: function () {
    }

});


//
//  Events extension
//

GE.Events.Com.Timer = {
    TICK: "com-timer-tick"
};

//
//  Component
//

/**
 *  Implements a timer that raises an event at user-defined intervals.
 *
 *  @class Timer
 *  @constructor
 */
AGE.Com.Timer = GE.Klass(GE.Component, {

    //  *****************************
    //  Class Definitions
    //  *****************************

    $name: "Com.Timer",

    //  *****************************
    //  Attributes
    //  *****************************

    __timeout: null,

    __enabled: false,

    alarmId: 0,

    loop: false,

    time: 1000,

    //  *****************************
    //  Ctor
    //  *****************************

    initialize: function (name) {
        this.$super(name);
    },

    //  *****************************
    //  Component Methods
    //  *****************************

    load: function () {

        //  Create alarms attribute in entity

        if (typeof this.entity.alarms == 'undefined') {
            this.entity.__alarmId = 0;
            this.entity.alarms = {};
        }

        //  Add to entity

        this.id = ++this.entity.__alarmId;

        this.entity.alarms[this.alarmId] = this;
    },

    dispose: function () {

        //  Stop the clock

        this.stop();

        //  Remove from entity

        delete this.entity.alarms[this.alarmId];
    },

    //  *****************************
    //  Public Methods
    //  *****************************

    /**
     *   Starts the timer.
     *
     *   @method start
     *   @param {array} [options]
     *   @param {int}  [options.time=1000] Time in milliseconds.
     *   @param {boolean} [options.loop=false] Auto-restart timer?
     **/
    start: function (options) {
        if(this.__enabled) {
            console.warn("Alarm "+this.alarmId + " was enabled.");
            return this;
        }

        this.__enabled = true;

        if(options) {

            if (typeof options["time"] !== 'undefined') {
                this.time = options["time"];
            }
            if (typeof options["loop"] !== 'undefined') {
                this.loop = options["loop"];
            }
        }

        this.__timeout = setTimeout(this.__onTick, this.time);

        return this;
    },

    /**
     * TO DOC
     *
     * @return {boolean} `true` if the timer is enabled, `false` otherwise.
     */
    isEnabled: function() {
        return this.__enabled;
    },

    /**
     *  Stops the timer.
     *  @method stop
     */
    stop: function () {
        this.__enabled = false;
        if(this.__timeout) {
            clearTimeout(this.__timeout);
            this.__timeout = null;
        }

        return this;
    },

    /**
     * On tick callback.
     */
    __onTick: function() {
        this.trigger(GE.Events.Com.Timer.TICK, this);

        //  If user don't stops the timer in the tick event
        if(this.__enabled) {

            this.__timeout = null;
            this.stop();

            if(this.loop) {
                this.start();
            }

        }
    }.$bound()
});
